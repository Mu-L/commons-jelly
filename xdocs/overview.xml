<?xml version="1.0"?>

<document>

 <properties>
  <title>Jelly Overview</title>
  <author email="jstrachan@apache.org">James Strachan</author>
 </properties>

<body>

<section name="Jelly Overview">

<p>Jelly is an XML based <i>processing engine</i>. The basic idea is that XML 
elements can be bound to a Java <i>Tag</i> which is a Java bean that performs 
some function. Here's an example action</p>

<pre>public class FooTag extends TagSupport {    
    private int count;
    public void setCount(int count) {
        this.count = count;
    }
    public void run(XMLOutput output) throws Exception {
        for ( int i = 0; i &lt; count; i++ ) {
            // evaluate body
            getBody().run( context, output );
        }
    }
}</pre>

<p>Then in a Jelly script this tag could be used as follows:-</p>

<pre>&lt;f:foo count=&quot;123&quot;&gt;
    something...
&lt;/f:foo&gt;</pre>

<p>Jelly is totally extendable 
via custom actions (in a similar way to JSP custom tags) as well as cleanly integrating with scripting 
languages such as Jexl, Velocity, pnuts, beanshell and via BSF (Bean Scripting Framework) 
languages like JavaScript &amp; JPython</p>

<p>Also notice that Jelly uses an <i>XMLOutput</i> class which extends SAX ContentHandler
to output XML events.
This makes Jelly ideal for XML content generation, SOAP scripting or dynamic web site generation.
A single Jelly tag can produce, consume, filter or transform XML events. This leads to a powerful
XML pipeline engine similar in some ways to Cocoon.
</p>

</section>

<section name="Background">

<p>It seems quite common these days to define custom XML languages to perform 
some kind of processing. Here are a few examples</p>

<ul>
  <li><a href="http://jakarta.apache.org/ant/">Ant</a></li>
  <li>XSLT</li>
  <li><a href="http://www.w3.org/TR/xml-pipeline/">XML Pipeline language</a></li>
  <li>JSTL and JSP custom tags</li>
  <li>Latka,  AntEater &amp; other similar XML based unit testing frameworks</li>
  <li>commons-workflow</li>
</ul>

<p>So the motivation behind Jelly was to create a simple XML based processing 
engine that could be extended to support various custom actions. A fully 
qualified XML element name can be mapped to a Java Bean (or DynaBean), the 
attributes map to bean properties, once the bean is constructed and the 
properties set it is executed via the Tag interfaces run() method. So custom 
actions can perform all kinds of processing from lower level looping, 
conditional logic and expression evaluations to higher level actions like post 
processing their bodies, making 
a HTTP, SOAP or JMS call, querying SQL databases etc.</p>

</section>

<section name="Comparisons">

<p>To try give you a better feel for what Jelly is, we'll compare and contrast 
Jelly with other scripting engines and templating technologies.</p>

<section name="Jelly versus JSP">

<p>Similarities</p>
<ul>
  <li>Jelly uses the concept of custom tag libraries from JSP and follows many 
  of the lessons learnt from the JSTL (JSP Standard Tag Library). Indeed JSTL 
  could be implemented in Jelly.</li>
</ul>

<p>Differences</p>
<ul>
  <li>Jelly has no dependency on Servlets or JSP so Jelly can be run from the 
  command line, inside Ant, inside an applet or anywhere that Java code can be 
  ran.</li>
  <li>Jelly tags are much simpler to write and use than JSP tags. Because JSP 
  must support scriptlets due to backwards compatibility issues, they are 
  implemented 'inside out' with 3 different interfaces (Tag, BodyTag, 
  IterationTag) to implement based on the kind of tag you are writing, together 
  with a fairly complex set of event-based methods that are called by the page 
  container. Jelly tags are very easy - just derive from TagSupport and 
  implement the run() method. Really simple!</li>
  <li>Jelly is XML native both as the format of the scripts and the output 
  format, so its ideal for work with XML and XML based applications and web 
  services</li>
  <li>Jelly tags can parse and compile their bodies for more optimal performance 
  and easier validation. So a tag can ignore whitespace, iterate over its body, 
  transform its body at compile time etc. So a Jelly tag can be a simple macro, preprocessing 
  its body at compile time, such as to build smart HTML forms or to make SOAP 
  macros etc.</li>
</ul>

</section>

<section name="Jelly versus Velocity">

<p>Velocity could actually be used inside Jelly via custom tags which support 
Velocity expressions, directives and scripts. However here's a head to head 
comparison anyways.</p>

<p>Similarities</p>
<ul>
  <li>Jelly allows Java objects to be manipulated in a Java-like manner just 
  like Velocity.</li>
  <li>Jelly could have a <i>surface syntax</i> that looks similar to Velocity. 
  i.e. someone could make a parser of Jelly that had a look-and-feel of Velocity 
  for common directives and expressions.</li>
</ul>

<p>Differences</p>
<ul>
  <li>Jelly provides an extensible tag mechanism to provide more poweful 
  scripting such as by supporting JSTL, XML, XPath, XSLT, SQL or SOAP service 
  scripting. In essence, Jelly uses XML tags to denote 'directives'.</li>
  <li>Jelly has integrated support for other scripting languages such as 
  JavaScript, NetRexx, Jython etc.</li>
</ul>

</section>
</section>

<section name="Possible uses for Jelly">

<p>Jelly has various possible uses. Here's a few to think about</p>
<ul>
  <li>SOAP scripting engine</li>
  <li>HTTP and/or JMS based scripting and unit testing framework similar to Latka and AntEater</li>
  <li>XML or page templating system</li>
  <li>Ant scripting</li>
  <li>Alternative (very lightweight) implementation of JSTL that can be run from 
  Ant to generate static content</li>
  <li>A workflow, EAI or integration, maybe integrated into commons-workflow</li>
  <li>Code generation system, maybe an enhanced scripting engine for XDoclet</li>
</ul>

</section>


</body>
</document>
